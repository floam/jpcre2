<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.11">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>JPCRE2</title>
    <detaileddescription>
<para>C++ wrapper of PCRE2 library</para><para><ulink url="https://travis-ci.org/jpcre2/jpcre2/"></ulink> <ulink url="https://neurobin.org/docs/libs/jpcre2"></ulink></para><para>PCRE2 is the name used for a revised API for the PCRE library, which is a set of functions, written in C, that implement regular expression pattern matching using the same syntax and semantics as Perl, with just a few differences. Some features that appeared in Python and the original PCRE before they appeared in Perl are also available using the Python syntax.</para><para>This provides some C++ wrapper functions to provide some useful utilities like regex match and regex replace.</para><sect1 id="index_1dependency">
<title>Dependency</title>
<para><orderedlist>
<listitem><para>PCRE2 library (<computeroutput>version &gt;=10.21</computeroutput>).</para></listitem></orderedlist>
</para><para>If the required PCRE2 version is not available in the official channel, download <ulink url="https://github.com/jpcre2/pcre2">my fork of the library</ulink>.</para></sect1>
<sect1 id="index_1install-or-include">
<title>Install or Include</title>
<para>The <computeroutput><ref refid="jpcre2_8hpp" kindref="compound">jpcre2.hpp</ref></computeroutput> header should be included in the source file that uses JPCRE2 functionalities.</para><sect2 id="index_1use-with-sources">
<title>Use with sources</title>
<para>After including the header you can compile your source either by installing and linking with JPCRE2 library or providing the following sources to your compiler:</para><para><orderedlist>
<listitem><para><bold><ref refid="jpcre2_8hpp" kindref="compound">jpcre2.hpp</ref></bold></para></listitem><listitem><para><bold>jpcre2.cpp</bold></para></listitem></orderedlist>
</para><para>An example compile/build command with GCC would be:</para><para><programlisting><codeline><highlight class="normal">g++<sp/>mycpp.cpp<sp/>jpcre2.cpp<sp/>jpcre2.hpp<sp/>-lpcre2-8</highlight></codeline>
</programlisting></para><para>If your PCRE2 library is not in the standard library path, then add the path:</para><para><programlisting><codeline><highlight class="normal">g++<sp/>mycpp.cpp<sp/>...<sp/>-L/path/to/your/pcre2/library<sp/>-lpcre2-8</highlight></codeline>
</programlisting></para><para><bold>Note that</bold> it requires the PCRE2 library installed in your system. If it is not already installed and linked in your compiler, you will need to link it with appropriate path and options.</para></sect2>
<sect2 id="index_1install-as-a-library">
<title>Use as a library</title>
<para>To install it as a library in a Unix based system, run:</para><para><programlisting><codeline><highlight class="normal">./configure</highlight></codeline>
<codeline><highlight class="normal">make</highlight></codeline>
<codeline><highlight class="normal">make<sp/>install<sp/>#<sp/>or<sp/>sudo<sp/>make<sp/>install</highlight></codeline>
</programlisting> Now <computeroutput>#include &lt;<ref refid="jpcre2_8hpp" kindref="compound">jpcre2.hpp</ref>&gt;</computeroutput> in your code and build/compile by linking with both JPCRE2 and PCRE2 library.</para><para>An example command for GCC would be:</para><para><programlisting><codeline><highlight class="normal">g++<sp/><sp/>mycpp.cpp<sp/>-ljpcre2-8<sp/>-lpcre2-8<sp/>#sequence<sp/>is<sp/>important</highlight></codeline>
</programlisting></para><para>If you are in a non-Unix system (e.g Windows), build a library from the JPCRE2 sources with your favorite IDE or use it as it is.</para><para><bold>Notes:</bold></para><para><orderedlist>
<listitem><para>Only <computeroutput>PCRE2_CODE_UNIT_WIDTH</computeroutput> 8 is supported in this version.</para></listitem><listitem><para>To use the <computeroutput>PCRE2 POSIX</computeroutput> compatible library, add the <computeroutput>-lpcre2-posix</computeroutput> along with the others.</para></listitem></orderedlist>
</para></sect2>
</sect1>
<sect1 id="index_1how-to-code-with-jpcre2">
<title>How to code with JPCRE2</title>
<para>Performing a match or replacement against regex pattern involves two steps:</para><para><orderedlist>
<listitem><para>Compiling the pattern</para></listitem><listitem><para>Performing the match or replacement operation</para></listitem></orderedlist>
</para><sect2 id="index_1compile-a-pattern">
<title>Compile a pattern</title>
<para><bold>First create a <computeroutput><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref></computeroutput> object</bold></para><para>(You can use temporary object too, see <ulink url="#short-examples">short examples</ulink>).</para><para>This object will hold the pattern, modifiers, compiled pattern, error and warning codes.</para><para><programlisting><codeline><highlight class="normal"><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref><sp/>re;<sp/><sp/><sp/></highlight><highlight class="comment">//Create<sp/>object,<sp/>it&apos;s<sp/>not<sp/>supposed<sp/>to<sp/>throw<sp/>exception</highlight></codeline>
</programlisting> Each object for each regex pattern.</para><para><bold>Compile the pattern</bold> and catch any error exception:</para><para><programlisting><codeline><highlight class="keywordflow">try</highlight><highlight class="normal">{re.<ref refid="classjpcre2_1_1Regex_1a85d9a514ea86ae68533223adac6c6bd8" kindref="member">setPattern</ref>(</highlight><highlight class="stringliteral">&quot;(?:(?&lt;word&gt;[?.#@:]+)|(?&lt;word&gt;\\w+))\\s*(?&lt;digit&gt;\\d+)&quot;</highlight><highlight class="normal">)<sp/><sp/></highlight><highlight class="comment">//set<sp/>pattern</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1Regex_1a03974fa7ba8f7c47186cb8d6f54934de" kindref="member">addJpcre2Option</ref>(<ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a9124b768bcae4d51430aa7f26126f387" kindref="member">jpcre2::VALIDATE_MODIFIER</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//modifier<sp/>goes<sp/>through<sp/>validation<sp/>check</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a5e8bab7c478015b19baf3e84ed00876e" kindref="member">jpcre2::JIT_COMPILE</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//perform<sp/>JIT<sp/>compile</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a6fec35fc9fdd8a606bed430c1816c552" kindref="member">jpcre2::ERROR_ALL</ref>)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//treat<sp/>warnings<sp/>as<sp/>errors</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1Regex_1ab1af1471339602446d8221b8c97c6b55" kindref="member">addModifier</ref>(</highlight><highlight class="stringliteral">&quot;nJ&quot;</highlight><highlight class="normal">)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//add<sp/>modifier</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1Regex_1a2c7dcf12f26b2b046e147b013c8b5087" kindref="member">addPcre2Option</ref>(0)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//add<sp/>pcre2<sp/>option</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1Regex_1aad1d5ef1e87f762f68a587eec4022e69" kindref="member">compile</ref>();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Finally<sp/>compile<sp/>it.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Do<sp/>not<sp/>use<sp/>setModifier()<sp/>after<sp/>adding<sp/>any<sp/>options,<sp/>it<sp/>will<sp/>reset<sp/>them.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Another<sp/>way<sp/>is<sp/>to<sp/>use<sp/>constructor<sp/>to<sp/>initialize<sp/>and<sp/>compile<sp/>at<sp/>the<sp/>same<sp/>time:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref><sp/>re2(</highlight><highlight class="stringliteral">&quot;pattern2&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;mSi&quot;</highlight><highlight class="normal">);<sp/><sp/></highlight><highlight class="comment">//S<sp/>is<sp/>an<sp/>optimization<sp/>mod.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref><sp/>re3(</highlight><highlight class="stringliteral">&quot;pattern3&quot;</highlight><highlight class="normal">,<sp/>PCRE2_ANCHORED);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref><sp/>re4(</highlight><highlight class="stringliteral">&quot;pattern4&quot;</highlight><highlight class="normal">,<sp/>PCRE2_ANCHORED,<sp/><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a5e8bab7c478015b19baf3e84ed00876e" kindref="member">jpcre2::JIT_COMPILE</ref>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(<ref refid="classjpcre2_1_1Except" kindref="compound">jpcre2::Except</ref>&amp;<sp/>e){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*Handle<sp/>error*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr&lt;&lt;e.<ref refid="classjpcre2_1_1Except_1aa9f557fe16222ac89a30c438212c0c09" kindref="member">getErrorMessage</ref>()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Now you can perform match or replace against the pattern. Use the <computeroutput>match()</computeroutput> member function to perform regex match and the <computeroutput>replace()</computeroutput> member function to perform regex replace.</para></sect2>
<sect2 id="index_1match">
<title>Match</title>
<para>The <computeroutput><ref refid="classjpcre2_1_1Regex_1a9ffbb6aa54cb97125f1b4211bc1d09a5" kindref="member">jpcre2::Regex::match(const String&amp; s)</ref></computeroutput> member function can take two arguments (subject &amp; modifier) and returns the number of matches found against the compiled pattern.</para><para>To get the match result (captured groups) however, you need to call the <computeroutput><ref refid="classjpcre2_1_1RegexMatch_1a5868aef3a146594ea1ebef34d122bb33" kindref="member">jpcre2::RegexMatch::match()</ref></computeroutput> function. Point be noted that, you can not call this function directly or create any object of the class <computeroutput><ref refid="classjpcre2_1_1RegexMatch" kindref="compound">jpcre2::RegexMatch</ref></computeroutput>. To call this function, first invoke the <computeroutput><ref refid="classjpcre2_1_1Regex_1a519b0915bf1163c6ce6a4d674b30cfcd" kindref="member">jpcre2::Regex::initMatch()</ref></computeroutput> function. It will give you a temporary <computeroutput><ref refid="classjpcre2_1_1RegexMatch" kindref="compound">jpcre2::RegexMatch</ref></computeroutput> object. Now you can chain function calls of <computeroutput><ref refid="classjpcre2_1_1RegexMatch_1a2c7efe1ec2e13827f670db4ecedcd0a0" kindref="member">jpcre2::RegexMatch::setNumberedSubstringVector(VecNum* vec_num)</ref></computeroutput> and such functions from <computeroutput><ref refid="classjpcre2_1_1RegexMatch" kindref="compound">jpcre2::RegexMatch</ref></computeroutput> class to pass various parameters. After you are done passing all the parameter that you need, the <computeroutput><ref refid="classjpcre2_1_1RegexMatch_1a5868aef3a146594ea1ebef34d122bb33" kindref="member">jpcre2::RegexMatch::match()</ref></computeroutput> function should be called to perform the actual match and return the match count. The match results will be stored in vectors (vectors of maps) whose pointers were passed as parameters.</para><para><emphasis>You should catch any error exception that may be thrown in case error occurs.</emphasis></para><sect3 id="index_1simple-match-count">
<title>Get match count</title>
<para><programlisting><codeline><highlight class="comment">//If<sp/>you<sp/>want<sp/>to<sp/>match<sp/>all<sp/>and<sp/>get<sp/>the<sp/>match<sp/>count,<sp/>use<sp/>the<sp/>action<sp/>modifier<sp/>&apos;g&apos;:</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count<sp/>=<sp/><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;(\\d)|(\\w)&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;m&quot;</highlight><highlight class="normal">).<ref refid="classjpcre2_1_1Regex_1ab93775a93a0a537d09b9e9ab4a5a3894" kindref="member">match</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>the<sp/>subject&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;g&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1do-match">
<title>Get match result</title>
<para>To get the match results, you need to pass appropriate vector pointers. This is an example of how you can get the numbered substrings/captured groups from a match:</para><para><programlisting><codeline><highlight class="normal"><ref refid="namespacejpcre2_1ac1cf752c8fbb0be78020be3b80e77ce3" kindref="member">jpcre2::VecNum</ref><sp/>vec_num;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count=re.<ref refid="classjpcre2_1_1Regex_1a519b0915bf1163c6ce6a4d674b30cfcd" kindref="member">initMatch</ref>()<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//prepare<sp/>for<sp/>match()<sp/>call</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a635c652195deaa8ebb9e107c4f972aab" kindref="member">setSubject</ref>(subject)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//set<sp/>subject<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a9df7e92f96b61553f62720cb8f5f23e5" kindref="member">setModifier</ref>(ac_mod)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//set<sp/>modifier<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a2c7efe1ec2e13827f670db4ecedcd0a0" kindref="member">setNumberedSubstringVector</ref>(&amp;vec_num)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pass<sp/>VecNum<sp/>vector<sp/>to<sp/>store<sp/>maps<sp/>of<sp/>numbered<sp/>substrings</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a5868aef3a146594ea1ebef34d122bb33" kindref="member">match</ref>();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Finally<sp/>perform<sp/>the<sp/>match.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//vec_num<sp/>will<sp/>be<sp/>populated<sp/>with<sp/>maps<sp/>of<sp/>numbered<sp/>substrings.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//count<sp/>is<sp/>the<sp/>total<sp/>number<sp/>of<sp/>matches<sp/>found</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(<ref refid="classjpcre2_1_1Except" kindref="compound">jpcre2::Except</ref>&amp;<sp/>e){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*Handle<sp/>error*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr&lt;&lt;e.<ref refid="classjpcre2_1_1Except_1aa9f557fe16222ac89a30c438212c0c09" kindref="member">getErrorMessage</ref>()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect3>
<sect3 id="index_1access-a-capture-group">
<title>Access a captured group</title>
<para>You can access a substring/captured group by specifying their index (position):</para><para><programlisting><codeline><highlight class="normal">std::cout&lt;&lt;vec_num[0][0];<sp/></highlight><highlight class="comment">//<sp/>group<sp/>0<sp/>in<sp/>first<sp/>match</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;vec_num[0][1];<sp/></highlight><highlight class="comment">//<sp/>group<sp/>1<sp/>in<sp/>first<sp/>match</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;vec_num[1][0];<sp/></highlight><highlight class="comment">//<sp/>group<sp/>0<sp/>in<sp/>second<sp/>match</highlight></codeline>
</programlisting> </para></sect3>
<sect3 id="index_1get-named-capture-group">
<title>Get named capture group</title>
<para>To get named substring and/or name to number mapping, pass pointer to the appropriate vectors with <computeroutput><ref refid="classjpcre2_1_1RegexMatch_1ae495431f57cae54363331237ab21b56c" kindref="member">jpcre2::RegexMatch::setNamedSubstringVector()</ref></computeroutput> and/or <computeroutput><ref refid="classjpcre2_1_1RegexMatch_1a04926e61d8b5f1d8bdf344efecd567d8" kindref="member">jpcre2::RegexMatch::setNameToNumberMapVector()</ref></computeroutput> before doing the match.</para><para><programlisting><codeline><highlight class="normal"><ref refid="namespacejpcre2_1ac1cf752c8fbb0be78020be3b80e77ce3" kindref="member">jpcre2::VecNum</ref><sp/>vec_num;<sp/><sp/><sp/></highlight><highlight class="comment">///Vector<sp/>to<sp/>store<sp/>numbered<sp/>substring<sp/>Map.</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><ref refid="namespacejpcre2_1a2b121ae776ea5b2913839f418a7d856b" kindref="member">jpcre2::VecNas</ref><sp/>vec_nas;<sp/><sp/><sp/></highlight><highlight class="comment">///Vector<sp/>to<sp/>store<sp/>named<sp/>substring<sp/>Map.</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><ref refid="namespacejpcre2_1a88a7aaf84cad627d34c8152e726168eb" kindref="member">jpcre2::VecNtN</ref><sp/>vec_ntn;<sp/><sp/><sp/></highlight><highlight class="comment">///Vector<sp/>to<sp/>store<sp/>Named<sp/>substring<sp/>to<sp/>Number<sp/>Map.</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::string<sp/>ac_mod=</highlight><highlight class="stringliteral">&quot;g&quot;</highlight><highlight class="normal">;<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>g<sp/>is<sp/>for<sp/>global<sp/>match.<sp/>Equivalent<sp/>to<sp/>using<sp/>setFindAll()<sp/>or<sp/>FIND_ALL<sp/>in<sp/>addJpcre2Options()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>re.<ref refid="classjpcre2_1_1Regex_1a519b0915bf1163c6ce6a4d674b30cfcd" kindref="member">initMatch</ref>()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a635c652195deaa8ebb9e107c4f972aab" kindref="member">setSubject</ref>(subject)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//set<sp/>subject<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a9df7e92f96b61553f62720cb8f5f23e5" kindref="member">setModifier</ref>(ac_mod)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//set<sp/>modifier<sp/>string</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a2c7efe1ec2e13827f670db4ecedcd0a0" kindref="member">setNumberedSubstringVector</ref>(&amp;vec_num)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pass<sp/>pointer<sp/>to<sp/>vector<sp/>of<sp/>numbered<sp/>substring<sp/>maps</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1ae495431f57cae54363331237ab21b56c" kindref="member">setNamedSubstringVector</ref>(&amp;vec_nas)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pass<sp/>pointer<sp/>to<sp/>vector<sp/>of<sp/>named<sp/>substring<sp/>maps</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a04926e61d8b5f1d8bdf344efecd567d8" kindref="member">setNameToNumberMapVector</ref>(&amp;vec_ntn)<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//pass<sp/>pointer<sp/>to<sp/>vector<sp/>of<sp/>name<sp/>to<sp/>number<sp/>maps</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a5868aef3a146594ea1ebef34d122bb33" kindref="member">match</ref>();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Finally<sp/>perform<sp/>the<sp/>match()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(<ref refid="classjpcre2_1_1Except" kindref="compound">jpcre2::Except</ref>&amp;<sp/>e){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*Handle<sp/>error*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr&lt;&lt;e.<ref refid="classjpcre2_1_1Except_1aa9f557fe16222ac89a30c438212c0c09" kindref="member">getErrorMessage</ref>()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1access-substring-by-name">
<title>Access a capture group by name</title>
<para><programlisting><codeline><highlight class="normal">std::cout&lt;&lt;vec_nas[0][</highlight><highlight class="stringliteral">&quot;name&quot;</highlight><highlight class="normal">];<sp/></highlight><highlight class="comment">//<sp/>captured<sp/>group<sp/>by<sp/>name<sp/>in<sp/>first<sp/>match</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;vec_nas[1][</highlight><highlight class="stringliteral">&quot;name&quot;</highlight><highlight class="normal">];<sp/></highlight><highlight class="comment">//<sp/>captured<sp/>group<sp/>by<sp/>name<sp/>in<sp/>second<sp/>match</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1get-number-to-name">
<title>Get the position of a capture group name</title>
<para>If you need this information, you should have passed a <computeroutput><ref refid="namespacejpcre2_1a88a7aaf84cad627d34c8152e726168eb" kindref="member">jpcre2::VecNtN</ref></computeroutput> pointer to <computeroutput><ref refid="classjpcre2_1_1RegexMatch_1a04926e61d8b5f1d8bdf344efecd567d8" kindref="member">jpcre2::RegexMatch::setNameToNumberMapVector()</ref></computeroutput> function before doing the match (<ulink url="#get-named-capture-group">see above</ulink>).</para><para><programlisting><codeline><highlight class="normal">std::cout&lt;&lt;vec_ntn[0][</highlight><highlight class="stringliteral">&quot;name&quot;</highlight><highlight class="normal">];<sp/></highlight><highlight class="comment">//<sp/>position<sp/>of<sp/>captured<sp/>group<sp/>&apos;name&apos;<sp/>in<sp/>first<sp/>match</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1iterate">
<title>Iterate through match result</title>
<para>You can iterate through the matches and their substrings like this:</para><para><programlisting><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;i&lt;vec_num.size();++i){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//i=0<sp/>is<sp/>the<sp/>first<sp/>match<sp/>found,<sp/>i=1<sp/>is<sp/>the<sp/>second<sp/>and<sp/>so<sp/>forth</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(jpcre2::MapNum::iterator<sp/>ent=vec_num[i].begin();ent!=vec_num[i].end();++ent){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ent.first<sp/>is<sp/>the<sp/>number/position<sp/>of<sp/>substring<sp/>found</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//ent.second<sp/>is<sp/>the<sp/>substring<sp/>itself</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//when<sp/>ent-&gt;first<sp/>is<sp/>0,<sp/>ent-&gt;second<sp/>is<sp/>the<sp/>total<sp/>match.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n\t&quot;</highlight><highlight class="normal">&lt;&lt;ent-&gt;first&lt;&lt;</highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;ent-&gt;second&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>If you are using <computeroutput>&gt;=C++11</computeroutput>, you can make the loop a lot simpler:</para><para><programlisting><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;i&lt;vec_num.size();++i){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>ent<sp/>:<sp/>vec_num[i]){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n\t&quot;</highlight><highlight class="normal">&lt;&lt;ent.first&lt;&lt;</highlight><highlight class="stringliteral">&quot;:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;ent.second&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><emphasis>The process of iterating through the vectors and associated maps are the same for all three. The size of those vectors are the same and can be accessed in the same way.</emphasis></para></sect3>
</sect2>
<sect2 id="index_1replace">
<title>Replace or Substitute</title>
<para>The <computeroutput><ref refid="classjpcre2_1_1Regex_1addd7c21abd0f4cf6c532a7602cfb5835" kindref="member">jpcre2::Regex::replace(const String&amp; s, const String&amp; r)</ref></computeroutput> member function can take up-to three arguments (subject, replacement string, modifier) and returns the resultant replaced string.</para><para>If you want to pass more options or prefer a named parameter idiom, you will have to use the <computeroutput><ref refid="classjpcre2_1_1RegexReplace_1afd087fa7a9bfedec802d1a3dd7edbdd0" kindref="member">jpcre2::RegexReplace::replace()</ref></computeroutput> function instead. Point be noted that, all constructors of the <computeroutput><ref refid="classjpcre2_1_1RegexReplace" kindref="compound">jpcre2::RegexReplace</ref></computeroutput> class are private and thus you can&apos;t create any object of this class or call the mentioned function directly. In this case you need to call <computeroutput><ref refid="classjpcre2_1_1Regex_1ae7235a991492fa88f1bd3fb02d59cd0a" kindref="member">jpcre2::Regex::initReplace()</ref></computeroutput> function which will give you a temporary object that you can use to chain method calls to pass various options to be used by <computeroutput><ref refid="classjpcre2_1_1RegexReplace_1afd087fa7a9bfedec802d1a3dd7edbdd0" kindref="member">jpcre2::RegexReplace::replace()</ref></computeroutput> before calling it.</para><para><emphasis>You should catch any error exception that may be thrown in case error occurs.</emphasis></para><sect3 id="index_1simple-replace">
<title>Simple replacement</title>
<para><programlisting><codeline><highlight class="comment">//Using<sp/>a<sp/>temporary<sp/>regex<sp/>object</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;<ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;\\d+&quot;</highlight><highlight class="normal">).<ref refid="classjpcre2_1_1Regex_1ac592ce7a5e4210ed5f90a0105b1f2981" kindref="member">replace</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>digits<sp/>1234&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;5678&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;g&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//&apos;g&apos;<sp/>modifier<sp/>is<sp/>for<sp/>global<sp/>replacement</highlight></codeline>
</programlisting></para></sect3>
<sect3 id="index_1using-method-chaining">
<title>Using method chain</title>
<para><programlisting><codeline><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>re.<ref refid="classjpcre2_1_1Regex_1ae7235a991492fa88f1bd3fb02d59cd0a" kindref="member">initReplace</ref>()<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Prepare<sp/>to<sp/>call<sp/>jpcre2::RegexReplace::replace()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexReplace_1a46eefdb105827920bebc8436721fa4cb" kindref="member">setSubject</ref>(s)<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Set<sp/>various<sp/>parameters</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexReplace_1af1069f489de9b343493da2dc77b04c73" kindref="member">setReplaceWith</ref>(s2)<sp/><sp/></highlight><highlight class="comment">//...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexReplace_1ae2abe2994b0fbe54950f88e63000c910" kindref="member">setModifier</ref>(</highlight><highlight class="stringliteral">&quot;gE&quot;</highlight><highlight class="normal">)<sp/><sp/><sp/></highlight><highlight class="comment">//...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexReplace_1a3f86b1e11d08d0153a08244771e59061" kindref="member">addJpcre2Option</ref>(0)<sp/><sp/></highlight><highlight class="comment">//...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexReplace_1a3cfd03568b23bebcbb530a2c120b5d33" kindref="member">addPcre2Option</ref>(0)<sp/><sp/><sp/></highlight><highlight class="comment">//...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexReplace_1afd087fa7a9bfedec802d1a3dd7edbdd0" kindref="member">replace</ref>();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Finally<sp/>do<sp/>the<sp/>replacement.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//gE<sp/>is<sp/>the<sp/>modifier<sp/>passed<sp/>(global<sp/>and<sp/>unknown-unset-empty).</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//Access<sp/>substrings/captured<sp/>groups<sp/>with<sp/>${1234},$1234<sp/>(for<sp/>numbered<sp/>substrings)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>or<sp/>${name}<sp/>(for<sp/>named<sp/>substrings)<sp/>in<sp/>the<sp/>replacement<sp/>part<sp/>i.e<sp/>in<sp/>setReplaceWith()</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(<ref refid="classjpcre2_1_1Except" kindref="compound">jpcre2::Except</ref>&amp;<sp/>e){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*Handle<sp/>error*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cerr&lt;&lt;e.<ref refid="classjpcre2_1_1Except_1aa9f557fe16222ac89a30c438212c0c09" kindref="member">getErrorMessage</ref>()&lt;&lt;std::endl;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> If you pass the size of the resultant string with <computeroutput><ref refid="classjpcre2_1_1RegexReplace_1a452dd2632031a13b39c13b792f18a491" kindref="member">jpcre2::RegexReplace::setBufferSize()</ref></computeroutput> function, make sure it will be enough to store the whole resultant replaced string; otherwise the internal replace function (<computeroutput>pcre2_substitute()</computeroutput>) will be called <emphasis>twice</emphasis> to adjust the size of the buffer to hold the whole resultant string in order to avoid <computeroutput>PCRE2_ERROR_NOMEMORY</computeroutput> error.</para></sect3>
</sect2>
</sect1>
<sect1 id="index_1modifiers">
<title>Modifiers</title>
<para><bold>JPCRE2</bold> uses modifiers to control various options, type, behavior of the regex and its&apos; interactions with different functions that uses it.</para><para><blockquote><para>All modifier string are parsed and converted to equivalent PCRE2 and JPCRE2 options on the fly. If you don&apos;t want it to spend any time parsing modifier then pass the equivalent option directly with one of the many variants of <computeroutput>addJpcre2Option()</computeroutput> and <computeroutput>addPcre2Option()</computeroutput> functions. </para></blockquote></para><para>Types of modifiers available:</para><para><orderedlist>
<listitem><para>Compile modifier<orderedlist>
<listitem><para>Unique modifier</para></listitem><listitem><para>Combined or mixed modifier (e.g &apos;n&apos;)</para></listitem></orderedlist>
</para></listitem><listitem><para>Action modifier<orderedlist>
<listitem><para>Unique modifier</para></listitem><listitem><para>Combined or mixed modifier (e.g &apos;E&apos;)</para></listitem></orderedlist>
</para></listitem></orderedlist>
</para><sect2 id="index_1compile-modifier">
<title>Compile modifiers</title>
<para>These modifiers define the behavior of a regex pattern. They have more or less the same meaning as the <ulink url="https://php.net/manual/en/reference.pcre.pattern.modifiers.php">PHP regex modifiers</ulink> except for <computeroutput>e, j and n</computeroutput> (marked with <superscript>*</superscript>).</para><para><table rows="14" cols="2"><row>
<entry thead="yes"><para>Modifier </para></entry><entry thead="yes"><para>Details  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>e</computeroutput><superscript>*</superscript> </para></entry><entry thead="no"><para>Unset back-references in the pattern will match to empty strings. Equivalent to <computeroutput>PCRE2_MATCH_UNSET_BACKREF</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>i</computeroutput> </para></entry><entry thead="no"><para>Case-insensitive. Equivalent to <computeroutput>PCRE2_CASELESS</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>j</computeroutput><superscript>*</superscript> </para></entry><entry thead="no"><para><computeroutput>\u \U \x</computeroutput> and unset back-references will act as JavaScript standard. <itemizedlist>
<listitem>
<para><computeroutput></computeroutput> matches an upper case &quot;U&quot; character (by default it causes a compile time error if this option is not set).</para></listitem>
<listitem>
<para><computeroutput></computeroutput> matches a lower case &quot;u&quot; character unless it is followed by four hexadecimal digits, in which case the hexadecimal number defines the code point to match (by default it causes a compile time error if this option is not set).</para></listitem>
<listitem>
<para><computeroutput></computeroutput> matches a lower case &quot;x&quot; character unless it is followed by two hexadecimal digits, in which case the hexadecimal number defines the code point to match (By default, as in Perl, a hexadecimal number is always expected after <computeroutput></computeroutput>, but it may have zero, one, or two digits (so, for example, <computeroutput></computeroutput> matches a binary zero character followed by z) ).</para></listitem>
<listitem>
<para>Unset back-references in the pattern will match to empty strings.</para></listitem>
</itemizedlist>
</para></entry></row>
<row>
<entry thead="no"><para><computeroutput>m</computeroutput> </para></entry><entry thead="no"><para>Multi-line regex. Equivalent to <computeroutput>PCRE2_MULTILINE</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>n</computeroutput><superscript>*</superscript> </para></entry><entry thead="no"><para>Enable Unicode support for <computeroutput>\w \d</computeroutput> etc... in pattern. Equivalent to PCRE2_UTF | PCRE2_UCP. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>s</computeroutput> </para></entry><entry thead="no"><para>If this modifier is set, a dot meta-character in the pattern matches all characters, including newlines. Equivalent to <computeroutput>PCRE2_DOTALL</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>u</computeroutput> </para></entry><entry thead="no"><para>Enable UTF support.Treat pattern and subjects as UTF strings. It is equivalent to <computeroutput>PCRE2_UTF</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>x</computeroutput> </para></entry><entry thead="no"><para>Whitespace data characters in the pattern are totally ignored except when escaped or inside a character class, enables commentary in pattern. Equivalent to <computeroutput>PCRE2_EXTENDED</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>A</computeroutput> </para></entry><entry thead="no"><para>Match only at the first position. It is equivalent to <computeroutput>PCRE2_ANCHORED</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>D</computeroutput> </para></entry><entry thead="no"><para>A dollar meta-character in the pattern matches only at the end of the subject string. Without this modifier, a dollar also matches immediately before the final character if it is a newline (but not before any other newlines). This modifier is ignored if <computeroutput>m</computeroutput> modifier is set. Equivalent to <computeroutput>PCRE2_DOLLAR_ENDONLY</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>J</computeroutput> </para></entry><entry thead="no"><para>Allow duplicate names for sub-patterns. Equivalent to <computeroutput>PCRE2_DUPNAMES</computeroutput> option. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>S</computeroutput> </para></entry><entry thead="no"><para>When a pattern is going to be used several times, it is worth spending more time analyzing it in order to speed up the time taken for matching/replacing. It may also be beneficial for a very long subject string or pattern. Equivalent to an extra compilation with JIT_COMPILER with the option <computeroutput>PCRE2_JIT_COMPLETE</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>U</computeroutput> </para></entry><entry thead="no"><para>This modifier inverts the &quot;greediness&quot; of the quantifiers so that they are not greedy by default, but become greedy if followed by <computeroutput>?</computeroutput>. Equivalent to <computeroutput>PCRE2_UNGREEDY</computeroutput> option. </para></entry></row>
</table>
</para></sect2>
<sect2 id="index_1action-modifiers">
<title>Action modifiers</title>
<para>These modifiers are not compiled in the regex itself, rather they are used per call of each match, replace or compile function.</para><para><table rows="8" cols="3"><row>
<entry thead="yes"><para>Modifier </para></entry><entry thead="yes"><para>Action </para></entry><entry thead="yes"><para>Details  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>A</computeroutput> </para></entry><entry thead="no"><para>match </para></entry><entry thead="no"><para>Match at start. Equivalent to <computeroutput>PCRE2_ANCHORED</computeroutput>. Can be used in match operation. Setting this option only at match time (i.e regex was not compiled with this option) will disable optimization during match time. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>e</computeroutput> </para></entry><entry thead="no"><para>replace </para></entry><entry thead="no"><para>Replaces unset group with empty string. Equivalent to <computeroutput>PCRE2_SUBSTITUTE_UNSET_EMPTY</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>E</computeroutput> </para></entry><entry thead="no"><para>replace </para></entry><entry thead="no"><para>Extension of <computeroutput>e</computeroutput> modifier. Sets even unknown groups to empty string. Equivalent to PCRE2_SUBSTITUTE_UNSET_EMPTY | PCRE2_SUBSTITUTE_UNKNOWN_UNSET </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>g</computeroutput> </para></entry><entry thead="no"><para>match<linebreak/>
replace </para></entry><entry thead="no"><para>Global. Will perform global matching or replacement if passed. Equivalent to <computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00af29fccdb263520155e9c25a826a7200c" kindref="member">jpcre2::FIND_ALL</ref></computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>x</computeroutput> </para></entry><entry thead="no"><para>replace </para></entry><entry thead="no"><para>Extended replacement operation. Equivalent to <computeroutput>PCRE2_SUBSTITUTE_EXTENDED</computeroutput>. It enables some Bash like features:<linebreak/>
<computeroutput>${&lt;n&gt;:-&lt;string&gt;}</computeroutput><linebreak/>
<computeroutput>${&lt;n&gt;:+&lt;string1&gt;:&lt;string2&gt;}</computeroutput><linebreak/>
<computeroutput>&lt;n&gt;</computeroutput> may be a group number or a name. The first form specifies a default value. If group <computeroutput>&lt;n&gt;</computeroutput> is set, its value is inserted; if not, <computeroutput>&lt;string&gt;</computeroutput> is expanded and the result is inserted. The second form specifies strings that are expanded and inserted when group <computeroutput>&lt;n&gt;</computeroutput> is set or unset, respectively. The first form is just a convenient shorthand for <computeroutput>${&lt;n&gt;:+${&lt;n&gt;}:&lt;string&gt;}</computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>~</computeroutput> </para></entry><entry thead="no"><para>match<linebreak/>
replace<linebreak/>
compile </para></entry><entry thead="no"><para>Treat warnings as errors. Equivalent to <computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a6fec35fc9fdd8a606bed430c1816c552" kindref="member">jpcre2::ERROR_ALL</ref></computeroutput>. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput>&amp;</computeroutput> </para></entry><entry thead="no"><para>match<linebreak/>
replace<linebreak/>
compile </para></entry><entry thead="no"><para>Validate modifier. Throws <computeroutput><ref refid="namespacejpcre2_1_1ERROR_1a4b2998984439438fa9da8d7043909bc2a4115340549b623f4e2da285bf0aa9bff" kindref="member">jpcre2::ERROR::INVALID_MODIFIER</ref></computeroutput> error in case invalid modifier encountered. Equivalent to <computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a9124b768bcae4d51430aa7f26126f387" kindref="member">jpcre2::VALIDATE_MODIFIER</ref></computeroutput>. </para></entry></row>
</table>
</para></sect2>
</sect1>
<sect1 id="index_1options">
<title>Options</title>
<para>JPCRE2 allows both PCRE2 and native JPCRE2 options to be passed. PCRE2 options are recognized by the PCPRE2 library itself.</para><sect2 id="index_1jpcre-options">
<title>JPCRE2 options</title>
<para>These options are meaningful only for the <bold>JPCRE2</bold> library itself not the original <bold>PCRE2</bold> library. We use the <computeroutput><ref refid="classjpcre2_1_1Regex_1a03974fa7ba8f7c47186cb8d6f54934de" kindref="member">jpcre2::Regex::addJpcre2Option()</ref></computeroutput> and such functions to pass these options.</para><para><table rows="6" cols="2"><row>
<entry thead="yes"><para>Option </para></entry><entry thead="yes"><para>Details  </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00aecf4a781b081ff541006fbe84e143fb9" kindref="member">jpcre2::NONE</ref></computeroutput> </para></entry><entry thead="no"><para>This is the default option. Equivalent to 0 (zero). </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a9124b768bcae4d51430aa7f26126f387" kindref="member">jpcre2::VALIDATE_MODIFIER</ref></computeroutput> </para></entry><entry thead="no"><para>If this option is passed, modifiers will be subject to validation check. If any of them is invalid, a <computeroutput><ref refid="namespacejpcre2_1_1ERROR_1a4b2998984439438fa9da8d7043909bc2a4115340549b623f4e2da285bf0aa9bff" kindref="member">jpcre2::ERROR::INVALID_MODIFIER</ref></computeroutput> error exception will be thrown. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00af29fccdb263520155e9c25a826a7200c" kindref="member">jpcre2::FIND_ALL</ref></computeroutput> </para></entry><entry thead="no"><para>This option will do a global matching if passed during matching. The same can be achieved by passing the &apos;g&apos; modifier with <computeroutput><ref refid="classjpcre2_1_1RegexMatch_1a9df7e92f96b61553f62720cb8f5f23e5" kindref="member">jpcre2::RegexMatch::setModifier()</ref></computeroutput> function. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a6fec35fc9fdd8a606bed430c1816c552" kindref="member">jpcre2::ERROR_ALL</ref></computeroutput> </para></entry><entry thead="no"><para>Treat warnings as errors and throw exception. </para></entry></row>
<row>
<entry thead="no"><para><computeroutput><ref refid="namespacejpcre2_1a85c143271501e383843f45b9999c2f00a5e8bab7c478015b19baf3e84ed00876e" kindref="member">jpcre2::JIT_COMPILE</ref></computeroutput> </para></entry><entry thead="no"><para>This is same as passing the <computeroutput>S</computeroutput> modifier during pattern compilation. </para></entry></row>
</table>
</para></sect2>
<sect2 id="index_1pcre2-options">
<title>PCRE2 options</title>
<para>While having its own way of doing things, JPCRE2 also supports the traditional PCRE2 options to be passed. We use the <computeroutput><ref refid="classjpcre2_1_1Regex_1a2c7dcf12f26b2b046e147b013c8b5087" kindref="member">jpcre2::Regex::addPcre2Option()</ref></computeroutput> and such functions to pass the PCRE2 options. These options are the same as the PCRE2 library and have the same meaning. For example instead of passing the &apos;g&apos; modifier to the replacement operation we can also pass its PCRE2 equivalent <computeroutput>PCRE2_SUBSTITUTE_GLOBAL</computeroutput> to have the same effect.</para></sect2>
</sect1>
<sect1 id="index_1short-examples">
<title>Short examples</title>
<para><programlisting><codeline><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>count;</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///Check<sp/>if<sp/>string<sp/>matches<sp/>the<sp/>pattern</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment">/**</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>The<sp/>following<sp/>uses<sp/>a<sp/>temporary<sp/>Regex<sp/>object.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;(\\d)|(\\w)&quot;</highlight><highlight class="normal">).match(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>the<sp/>subject&quot;</highlight><highlight class="normal">))<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nmatched&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nno<sp/>match&quot;</highlight><highlight class="normal">;</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">/**</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>The<sp/>above<sp/>is<sp/>a<sp/>good<sp/>example<sp/>of<sp/>using<sp/>temporary<sp/>objects<sp/>to<sp/>perform<sp/>match<sp/>(or<sp/>replace)</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Using<sp/>the<sp/>modifier<sp/>S<sp/>(i.e<sp/>jpcre2::JIT_COMPILE)<sp/>with<sp/>temporary<sp/>object<sp/>may<sp/>or<sp/>may<sp/>not<sp/>give<sp/>you</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>any<sp/>performance<sp/>boost<sp/>(depends<sp/>on<sp/>the<sp/>complexity<sp/>of<sp/>the<sp/>pattern).<sp/>The<sp/>more<sp/>complex<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>the<sp/>pattern<sp/>gets,<sp/>the<sp/>more<sp/>sense<sp/>the<sp/>S<sp/>modifier<sp/>makes.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///If<sp/>you<sp/>want<sp/>to<sp/>match<sp/>all<sp/>and<sp/>get<sp/>the<sp/>match<sp/>count,<sp/>use<sp/>the<sp/>action<sp/>modifier<sp/>&apos;g&apos;:</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;(\\d)|(\\w)&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;m&quot;</highlight><highlight class="normal">).<ref refid="classjpcre2_1_1Regex_1ab93775a93a0a537d09b9e9ab4a5a3894" kindref="member">match</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>the<sp/>subject&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;g&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">/**</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Modifiers<sp/>passed<sp/>to<sp/>the<sp/>Regex<sp/>constructor<sp/>or<sp/>with<sp/>compile()<sp/>function<sp/>are<sp/>compile<sp/>modifiers</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Modifiers<sp/>passed<sp/>with<sp/>the<sp/>match()<sp/>or<sp/>replace()<sp/>functions<sp/>are<sp/>action<sp/>modifiers</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///<sp/>Substrings/Captured<sp/>groups:</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">/**</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>***<sp/>Getting<sp/>captured<sp/>groups/substring<sp/>***</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>captured<sp/>groups<sp/>or<sp/>substrings<sp/>are<sp/>stored<sp/>in<sp/>maps<sp/>for<sp/>each<sp/>match,</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>and<sp/>each<sp/>match<sp/>is<sp/>stored<sp/>in<sp/>a<sp/>vector.<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Thus<sp/>captured<sp/>groups<sp/>are<sp/>in<sp/>a<sp/>vector<sp/>of<sp/>maps.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>PCRE2<sp/>provides<sp/>two<sp/>types<sp/>of<sp/>substrings:</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>1.<sp/>numbered<sp/>(index)<sp/>substring</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>2.<sp/>named<sp/>substring</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>For<sp/>the<sp/>above<sp/>two,<sp/>we<sp/>have<sp/>two<sp/>vectors<sp/>respectively:</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>1.<sp/>jpcre2::VecNum<sp/>(Corresponding<sp/>map:<sp/>jpcre2::MapNum)</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>2.<sp/>jpcre2::VecNas<sp/>(Corresponding<sp/>map:<sp/>jpcre2::MapNas)</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Another<sp/>additional<sp/>vector<sp/>is<sp/>available<sp/>to<sp/>get<sp/>the<sp/>substring<sp/>position/number</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>for<sp/>a<sp/>particular<sp/>captured<sp/>group<sp/>by<sp/>name.<sp/>It&apos;s<sp/>a<sp/>vector<sp/>of<sp/>name<sp/>to<sp/>number<sp/>maps</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/><sp/>*<sp/>jpcre2::VecNtN<sp/>(Corresponding<sp/>map:<sp/>jpcre2:MapNtN)</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///<sp/>*****<sp/>Get<sp/>numbered<sp/>substring<sp/>*****<sp/>///</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><ref refid="namespacejpcre2_1ac1cf752c8fbb0be78020be3b80e77ce3" kindref="member">jpcre2::VecNum</ref><sp/>vec_num;</highlight></codeline>
<codeline><highlight class="normal">count<sp/>=<sp/></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;(\\w+)\\s*(\\d+)&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;m&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1Regex_1a519b0915bf1163c6ce6a4d674b30cfcd" kindref="member">initMatch</ref>()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a635c652195deaa8ebb9e107c4f972aab" kindref="member">setSubject</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>23,<sp/>I<sp/>am<sp/>digits<sp/>10&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a9df7e92f96b61553f62720cb8f5f23e5" kindref="member">setModifier</ref>(</highlight><highlight class="stringliteral">&quot;g&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a2c7efe1ec2e13827f670db4ecedcd0a0" kindref="member">setNumberedSubstringVector</ref>(&amp;vec_num)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a5868aef3a146594ea1ebef34d122bb33" kindref="member">match</ref>();</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">/**</highlight></codeline>
<codeline><highlight class="comment">*<sp/>count<sp/>(the<sp/>return<sp/>value)<sp/>is<sp/>guaranteed<sp/>to<sp/>give<sp/>you<sp/>the<sp/>correct<sp/>number<sp/>of<sp/>matches,</highlight></codeline>
<codeline><highlight class="comment">*<sp/>while<sp/>vec_num.size()<sp/>may<sp/>give<sp/>you<sp/>wrong<sp/>result<sp/>if<sp/>any<sp/>match<sp/>result</highlight></codeline>
<codeline><highlight class="comment">*<sp/>was<sp/>failed<sp/>to<sp/>be<sp/>inserted<sp/>in<sp/>the<sp/>vector.<sp/>This<sp/>should<sp/>not<sp/>happen</highlight></codeline>
<codeline><highlight class="comment">*<sp/>i.e<sp/>count<sp/>and<sp/>vec_num.size()<sp/>should<sp/>always<sp/>be<sp/>equal.</highlight></codeline>
<codeline><highlight class="comment">*<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nNumber<sp/>of<sp/>matches:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;count</highlight><highlight class="comment">/*<sp/>or<sp/>vec_num.size()*/</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///Now<sp/>vec_num<sp/>is<sp/>populated<sp/>with<sp/>numbered<sp/>substrings<sp/>for<sp/>each<sp/>match</highlight></codeline>
<codeline><highlight class="comment">///The<sp/>size<sp/>of<sp/>vec_num<sp/>is<sp/>the<sp/>total<sp/>match<sp/>count</highlight></codeline>
<codeline><highlight class="comment">///vec_num[0]<sp/>is<sp/>the<sp/>first<sp/>match</highlight></codeline>
<codeline><highlight class="comment">///The<sp/>type<sp/>of<sp/>vec_num[0]<sp/>is<sp/>jpcre2::MapNum</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nTotal<sp/>match<sp/>of<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_num[0][0];<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">///Total<sp/>match<sp/>(group<sp/>0)<sp/>from<sp/>first<sp/>match</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptrued<sp/>group<sp/>1<sp/>of<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_num[0][1];<sp/></highlight><highlight class="comment">///captured<sp/>group<sp/>1<sp/>from<sp/>first<sp/>match<sp/></highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptrued<sp/>group<sp/>2<sp/>of<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_num[0][2];<sp/></highlight><highlight class="comment">///captured<sp/>group<sp/>2<sp/>from<sp/>first<sp/>match</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptrued<sp/>group<sp/>3<sp/>of<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_num[0][3];<sp/></highlight><highlight class="comment">///captured<sp/>group<sp/>3<sp/>doesn&apos;t<sp/>exist,<sp/>it<sp/>will<sp/>give<sp/>you<sp/>empty<sp/>string</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment">///Using<sp/>the<sp/>[]<sp/>operator<sp/>with<sp/>jpcre2::MapNum<sp/>will<sp/>create<sp/>new<sp/>element<sp/>if<sp/>it<sp/>doesn&apos;t<sp/>exist</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment">///<sp/>i.e<sp/>vec_num[0][3]<sp/>were<sp/>created<sp/>in<sp/>the<sp/>above<sp/>example.</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment">///This<sp/>should<sp/>be<sp/>ok,<sp/>if<sp/>existence<sp/>of<sp/>a<sp/>particular<sp/>substring<sp/>is<sp/>not<sp/>important</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///If<sp/>the<sp/>existence<sp/>of<sp/>a<sp/>substring<sp/>is<sp/>important,<sp/>use<sp/>the<sp/>std::map::find()<sp/>or<sp/>std::map::at()<sp/>(&gt;=C++11)<sp/>function<sp/>to<sp/>access<sp/>map<sp/>elements</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment">/*<sp/>//&gt;=C++11</highlight></codeline>
<codeline><highlight class="comment">try{</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/>///This<sp/>will<sp/>throw<sp/>exception,<sp/>because<sp/>substring<sp/>4<sp/>doesn&apos;t<sp/>exist</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;&quot;\nCaptrued<sp/>group<sp/>4<sp/>of<sp/>first<sp/>match:<sp/>&quot;&lt;&lt;vec_num[0].at(4);</highlight></codeline>
<codeline><highlight class="normal">}<sp/>catch<sp/>(std::logic_error<sp/>e){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;&quot;\nCaptrued<sp/>group<sp/>4<sp/>doesn&apos;t<sp/>exist&quot;;</highlight></codeline>
<codeline><highlight class="normal">}*/</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///There<sp/>were<sp/>two<sp/>matches<sp/>found<sp/>(vec_num.size()<sp/>==<sp/>2)<sp/>in<sp/>the<sp/>above<sp/>example</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nTotal<sp/>match<sp/>of<sp/>second<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_num[1][0];<sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">///Total<sp/>match<sp/>(group<sp/>0)<sp/>from<sp/>second<sp/>match</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptrued<sp/>group<sp/>1<sp/>of<sp/>second<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_num[1][1];<sp/></highlight><highlight class="comment">///captured<sp/>group<sp/>1<sp/>from<sp/>second<sp/>match<sp/></highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptrued<sp/>group<sp/>2<sp/>of<sp/>second<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_num[1][2];<sp/></highlight><highlight class="comment">///captured<sp/>group<sp/>2<sp/>from<sp/>second<sp/>match</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///<sp/>*****<sp/>Get<sp/>named<sp/>substring<sp/>*****<sp/>///</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacejpcre2_1a2b121ae776ea5b2913839f418a7d856b" kindref="member">jpcre2::VecNas</ref><sp/>vec_nas;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacejpcre2_1a88a7aaf84cad627d34c8152e726168eb" kindref="member">jpcre2::VecNtN</ref><sp/>vec_ntn;<sp/></highlight><highlight class="comment">///<sp/>We<sp/>will<sp/>get<sp/>name<sp/>to<sp/>number<sp/>map<sp/>vector<sp/>too</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">count<sp/>=<sp/></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;(?&lt;word&gt;\\w+)\\s*(?&lt;digit&gt;\\d+)&quot;</highlight><highlight class="normal">,</highlight><highlight class="stringliteral">&quot;m&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1Regex_1a519b0915bf1163c6ce6a4d674b30cfcd" kindref="member">initMatch</ref>()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a635c652195deaa8ebb9e107c4f972aab" kindref="member">setSubject</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>23,<sp/>I<sp/>am<sp/>digits<sp/>10&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a9df7e92f96b61553f62720cb8f5f23e5" kindref="member">setModifier</ref>(</highlight><highlight class="stringliteral">&quot;g&quot;</highlight><highlight class="normal">)</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>///.setNumberedSubstringVector(vec_num)<sp/>///<sp/>We<sp/>don&apos;t<sp/>need<sp/>it<sp/>in<sp/>this<sp/>example</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1ae495431f57cae54363331237ab21b56c" kindref="member">setNamedSubstringVector</ref>(&amp;vec_nas)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a04926e61d8b5f1d8bdf344efecd567d8" kindref="member">setNameToNumberMapVector</ref>(&amp;vec_ntn)<sp/></highlight><highlight class="comment">///<sp/>Additional<sp/>(name<sp/>to<sp/>number<sp/>maps)</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1RegexMatch_1a5868aef3a146594ea1ebef34d122bb33" kindref="member">match</ref>();</highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nNumber<sp/>of<sp/>matches:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_nas.size()</highlight><highlight class="comment">/*<sp/>or<sp/>count<sp/>*/</highlight><highlight class="normal">;</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///Now<sp/>vec_nas<sp/>is<sp/>populated<sp/>with<sp/>named<sp/>substrings<sp/>for<sp/>each<sp/>match</highlight></codeline>
<codeline><highlight class="comment">///The<sp/>size<sp/>of<sp/>vec_nas<sp/>is<sp/>the<sp/>total<sp/>match<sp/>count</highlight></codeline>
<codeline><highlight class="comment">///vec_nas[0]<sp/>is<sp/>the<sp/>first<sp/>match</highlight></codeline>
<codeline><highlight class="comment">///The<sp/>type<sp/>of<sp/>vec_nas[0]<sp/>is<sp/>jpcre2::MapNas</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptured<sp/>group<sp/>(word)<sp/>of<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_nas[0][</highlight><highlight class="stringliteral">&quot;word&quot;</highlight><highlight class="normal">];</highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptured<sp/>group<sp/>(digit)<sp/>of<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_nas[0][</highlight><highlight class="stringliteral">&quot;digit&quot;</highlight><highlight class="normal">];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///If<sp/>the<sp/>existence<sp/>of<sp/>a<sp/>substring<sp/>is<sp/>important,<sp/>use<sp/>the<sp/>std::map::find()<sp/>or<sp/>std::map::at()<sp/>(&gt;=C++11)<sp/>function<sp/>to<sp/>access<sp/>map<sp/>elements</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="comment">/*<sp/>//&gt;=C++11</highlight></codeline>
<codeline><highlight class="comment">try{</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment"><sp/><sp/><sp/><sp/>///This<sp/>will<sp/>throw<sp/>exception<sp/>because<sp/>the<sp/>substring<sp/>name<sp/>&apos;name&apos;<sp/>doesn&apos;t<sp/>exist</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;&quot;\nCaptured<sp/>group<sp/>(name)<sp/>of<sp/>first<sp/>match:<sp/>&quot;&lt;&lt;vec_nas[0].at(&quot;name&quot;);</highlight></codeline>
<codeline><highlight class="normal">}<sp/>catch(std::logic_error<sp/>e){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::cout&lt;&lt;&quot;\nCaptured<sp/>group<sp/>(name)<sp/>doesn&apos;t<sp/>exist&quot;;</highlight></codeline>
<codeline><highlight class="normal">}*/</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///There<sp/>were<sp/>two<sp/>matches<sp/>found<sp/>(vec_nas.size()<sp/>==<sp/>2)<sp/>in<sp/>the<sp/>above<sp/>example</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptured<sp/>group<sp/>(word)<sp/>of<sp/>second<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_nas[1][</highlight><highlight class="stringliteral">&quot;word&quot;</highlight><highlight class="normal">];</highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nCaptured<sp/>group<sp/>(digit)<sp/>of<sp/>second<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_nas[1][</highlight><highlight class="stringliteral">&quot;digit&quot;</highlight><highlight class="normal">];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///Get<sp/>the<sp/>position<sp/>(number)<sp/>of<sp/>a<sp/>captured<sp/>group<sp/>name<sp/>(that<sp/>was<sp/>found<sp/>in<sp/>match)</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nPosition<sp/>of<sp/>captured<sp/>group<sp/>(word)<sp/>in<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_ntn[0][</highlight><highlight class="stringliteral">&quot;word&quot;</highlight><highlight class="normal">];</highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\nPosition<sp/>of<sp/>captured<sp/>group<sp/>(digit)<sp/>in<sp/>first<sp/>match:<sp/>&quot;</highlight><highlight class="normal">&lt;&lt;vec_ntn[0][</highlight><highlight class="stringliteral">&quot;digit&quot;</highlight><highlight class="normal">];</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">/**</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Replacement<sp/>Examples</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>Replace<sp/>pattern<sp/>in<sp/>a<sp/>string<sp/>with<sp/>a<sp/>replacement<sp/>string</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>The<sp/>initReplace()<sp/>function<sp/>can<sp/>take<sp/>a<sp/>subject<sp/>and<sp/>replacement<sp/>string<sp/>as<sp/>argument.</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>You<sp/>can<sp/>also<sp/>pass<sp/>the<sp/>subject<sp/>with<sp/>setSubject()<sp/>function<sp/>in<sp/>method<sp/>chain,</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>replacement<sp/>string<sp/>with<sp/>setReplaceWith()<sp/>function<sp/>in<sp/>method<sp/>chain,<sp/>etc<sp/>...</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>A<sp/>call<sp/>to<sp/>replace()<sp/>will<sp/>return<sp/>the<sp/>resultant<sp/>string</highlight></codeline>
<codeline><highlight class="comment"><sp/>*<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">&lt;&lt;</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///replace<sp/>first<sp/>occurrence<sp/>of<sp/>a<sp/>digit<sp/>with<sp/>@</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;\\d&quot;</highlight><highlight class="normal">).<ref refid="classjpcre2_1_1Regex_1ac592ce7a5e4210ed5f90a0105b1f2981" kindref="member">replace</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>the<sp/>subject<sp/>string<sp/>44&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;@&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">&lt;&lt;</highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///replace<sp/>all<sp/>occurrences<sp/>of<sp/>a<sp/>digit<sp/>with<sp/>@</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal"><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;\\d&quot;</highlight><highlight class="normal">).<ref refid="classjpcre2_1_1Regex_1ac592ce7a5e4210ed5f90a0105b1f2981" kindref="member">replace</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>the<sp/>subject<sp/>string<sp/>44&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;@&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;g&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment"></highlight></codeline>
<codeline><highlight class="comment">///swap<sp/>two<sp/>parts<sp/>of<sp/>a<sp/>string</highlight></codeline>
<codeline><highlight class="comment"></highlight><highlight class="normal">std::cout&lt;&lt;</highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classjpcre2_1_1Regex" kindref="compound">jpcre2::Regex</ref>(</highlight><highlight class="stringliteral">&quot;^([^\t]+)\t([^\t]+)$&quot;</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>.<ref refid="classjpcre2_1_1Regex_1ac592ce7a5e4210ed5f90a0105b1f2981" kindref="member">replace</ref>(</highlight><highlight class="stringliteral">&quot;I<sp/>am<sp/>the<sp/>subject\tTo<sp/>be<sp/>swapped<sp/>according<sp/>to<sp/>tab&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;$2<sp/>$1&quot;</highlight><highlight class="normal">);</highlight></codeline>
</programlisting> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
