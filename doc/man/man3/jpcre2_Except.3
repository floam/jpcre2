.TH "jpcre2::Except" 3 "Fri Sep 9 2016" "Version 10.25.04" "JPCRE2" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jpcre2::Except \- Class to handle exception\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <jpcre2\&.hpp>\fP
.PP
Inherits std::exception\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBExcept\fP (const std::string &msg, int err_num, int err_off)"
.br
.RI "Constructor (C++ STL string, int, int)\&. "
.ti -1c
.RI "virtual \fB~Except\fP ()  throw ()"
.br
.RI "Destructor\&. "
.ti -1c
.RI "virtual const char * \fBwhat\fP () const  throw ()"
.br
.RI "Returns a pointer to the (constant) error description\&. "
.ti -1c
.RI "virtual int \fBgetErrorNumber\fP () const  throw ()"
.br
.RI "Returns error number\&. "
.ti -1c
.RI "virtual int \fBgetErrorOffset\fP () const  throw ()"
.br
.RI "Returns error offset\&. "
.ti -1c
.RI "virtual const char * \fBgetErrorMessage\fP () const  throw ()"
.br
.RI "Just another name for \fBwhat()\fP for convenience\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "int \fBerror_number\fP"
.br
.RI "Error number\&. "
.ti -1c
.RI "int \fBerror_offset\fP"
.br
.RI "Error offset\&. "
.ti -1c
.RI "std::string \fBerror_message\fP"
.br
.RI "Error message\&. "
.in -1c
.SH "Detailed Description"
.PP 
Class to handle exception\&. 

Provides public functions to get the error number, error offset and error message\&.
.PP
In normal operation, when working with a valid regex with valid options no exception is supposed to occur\&. Most of the time you can get away without resorting to try catch block just by being a little careful about what you pass and what your environment supports\&.
.PP
Protecting your regex operation with try\&.\&.catch is not needed, but it's something for you to decide\&. For example, if your implementation needs to take regex pattern from user input and warn them about bad input, you will definitely need try catch\&.
.PP
Note that, bad input isn't the only reason that an exception can be thrown\&. As of original PCRE2 specs, you can get a load of errors for a load of unexpected situations\&. This is a rough list of causes:
.PP
.IP "1." 4
\fBBad input:\fP
.IP "  1." 6
Invalid modifier (only if validation check is enabled, otherwise ignored as warning)\&.
.IP "  2." 6
Incomplete options for regex pattern (Invalid option isn't an error, options that are not known or not applicable gets ignored graciously)\&.
.IP "  3." 6
Malicious options (Can produce undefined/unexpected behavior)\&.
.PP

.IP "2." 4
\fBPCRE2 errors:\fP These errors are well defined in the original PCRE2 specs\&.
.IP "3." 4
\fBRuntime error:\fP Error that happens for unknown/unexpected reasons\&. These errors are not thrown by \fBExcept\fP and therefore should be caught with std::exception
.PP
.PP
An example of catching all exceptions including runtime error and \fBExcept\fP errors:
.PP
.PP
.nf
try {
    jpcre2::Regex re("pattern", "mod"); //will not throw any exception for any sane cause\&.
} catch (std::exception& e) {
    std::cout<<e\&.what();
}
.fi
.PP
.PP
An example of catching only \fBjpcre2::Except\fP errors:
.PP
.PP
.nf
try {
    jpcre2::Regex re("pattern", "mod"); //will not throw any exception for any sane cause\&.
}
catch( jpcre2::Except& e){
    std::cout<<e\&.what();
}
.fi
.PP
 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "jpcre2::Except::Except (const std::string & msg, int err_num, int err_off)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Constructor (C++ STL string, int, int)\&. 
.PP
\fBParameters:\fP
.RS 4
\fImsg\fP The error message 
.br
\fIerr_num\fP Error number 
.br
\fIerr_off\fP Error offset 
.RE
.PP

.SS "virtual jpcre2::Except::~Except ()\fC [inline]\fP, \fC [virtual]\fP"

.PP
Destructor\&. Virtual to allow for subclassing\&. 
.SH "Member Function Documentation"
.PP 
.SS "virtual const char* jpcre2::Except::getErrorMessage () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Just another name for \fBwhat()\fP for convenience\&. Returns a pointer to the (constant) error description\&. 
.PP
\fBReturns:\fP
.RS 4
A pointer to a const char*\&. The underlying memory is in possession of the \fBExcept\fP object\&. Callers must not attempt to free the memory\&. 
.RE
.PP

.SS "virtual int jpcre2::Except::getErrorNumber () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns error number\&. 
.PP
\fBReturns:\fP
.RS 4
\fBerror_number\fP 
.RE
.PP

.SS "virtual int jpcre2::Except::getErrorOffset () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns error offset\&. 
.PP
\fBReturns:\fP
.RS 4
\fBerror_offset\fP 
.RE
.PP

.SS "virtual const char* jpcre2::Except::what () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Returns a pointer to the (constant) error description\&. 
.PP
\fBReturns:\fP
.RS 4
A pointer to a const char*\&. The underlying memory is in possession of the \fBExcept\fP object\&. Callers must not attempt to free the memory\&. 
.RE
.PP


.SH "Author"
.PP 
Generated automatically by Doxygen for JPCRE2 from the source code\&.
